
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Morningside Single-Family Parcels ≥ 0.25 ac</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html,body,#map { height: 100%; margin:0; padding:0; }
    .controls { position: absolute; top:8px; right:8px; z-index:999; background:white; padding:8px; border-radius:6px; box-shadow:0 1px 4px rgba(0,0,0,0.3); font-family: Arial, sans-serif; }
    .legend { background:white; padding:6px; border-radius:4px; }
    .btn { display:inline-block; padding:6px 8px; margin:4px 0; background:#1976d2; color:white; border-radius:4px; cursor:pointer; text-decoration:none; }
    .btn:disabled { background: #999; cursor: default; }
  </style>
</head>
<body>
<div id="map"></div>
<div class="controls">
  <div><strong>Morningside / Lenox Park — Single‑Family ≥ 0.25 ac</strong></div>
  <div style="margin-top:6px;">
    <button id="runBtn" class="btn">Load parcels</button>
    <button id="exportBtn" class="btn" disabled>Export GeoJSON</button>
  </div>
  <div style="margin-top:8px;font-size:12px;">
    Basemap: Streets (OpenStreetMap)<br/>
    Parcels from Fulton & DeKalb County; zoning from City of Atlanta.<br/>
    See README for data sources & notes.
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

<script>
// --- Configuration: REST endpoints (ArcGIS REST services) ---
// Neighborhoods (City of Atlanta OpenDataService1 - Neighborhoods layer ID 3)
const ATL_NEIGHBORHOODS_URL = 'https://gis.atlantaga.gov/dpcd/rest/services/OpenDataService1/MapServer/3/query';

// City of Atlanta zoning districts (OpenDataService1 layer 22)
const ATL_ZONING_URL = 'https://gis.atlantaga.gov/dpcd/rest/services/OpenDataService1/MapServer/22/query';

// Fulton County parcels (Fulton County PropertyMapViewer MapServer - will be queried)
// Note: the exact parcel layer in this service will be queried by geometry; using the PropertyMapViewer map service
const FULTON_PARCELS_URL = 'https://gismaps.fultoncountyga.gov/arcgispub2/rest/services/PropertyMapViewer/PropertyMapViewer/MapServer/query';

// DeKalb County parcels (DeKalb hosted MapServer)
const DEKALB_PARCELS_URL = 'https://dcgis.dekalbcountyga.gov/hosted/rest/services/Parcels/MapServer/query';

// Minimum area (sq ft) threshold (0.25 acre = 10,890 sq ft)
const MIN_SQFT = 10890;

// Zoning filter logic: treat a parcel as 'single-family' if it intersects a zoning polygon whose ZONECLASS contains 'Single' (case-insensitive)
// and/or the zone code starts with 'R' (a common convention for residential single-family in Atlanta).
// You can tweak this logic in the code below if you want a stricter or looser inclusion set.
function isSingleFamilyZone(zoneObj) {
  if (!zoneObj) return false;
  const z = String(zoneObj.ZONECLASS || zoneObj.ZoneClass || zoneObj.zoneclass || zoneObj.ZONE || '').toLowerCase();
  if (z.includes('single')) return true;
  // codes like 'R-1', 'R-4', etc.
  const display = String(zoneObj.ZONECLASS || zoneObj.ZONE || '').trim();
  if (/^r/i.test(display)) return true;
  return false;
}

// Leaflet map
const map = L.map('map').setView([33.780, -84.357], 15);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '© OpenStreetMap contributors'
}).addTo(map);

let resultsLayer = L.geoJSON(null, {style: ()=>({color:'#ff7800', weight:1.5, fill:false})}).addTo(map);
let neighborhoodLayer = L.geoJSON(null, {style: ()=>({color:'#1976d2', weight:2, fill:false})}).addTo(map);

// Utility: fetch ArcGIS JSON feature response and convert to GeoJSON features
async function arcgisQueryToGeoJSON(url, params) {
  const query = new URL(url);
  Object.keys(params).forEach(k => query.searchParams.append(k, params[k]));
  const resp = await fetch(query.toString());
  if (!resp.ok) throw new Error('Query failed: ' + resp.status);
  const data = await resp.json();
  // if it's already GeoJSON
  if (data.type === 'FeatureCollection') return data;
  // ArcGIS JSON to GeoJSON conversion (simple)
  if (data.features) {
    const features = data.features.map(f => {
      const geom = f.geometry;
      let gjGeom = null;
      if (geom) {
        if (geom.rings) gjGeom = {type:'Polygon', coordinates: geom.rings};
        else if (geom.x && geom.y) gjGeom = {type:'Point', coordinates:[geom.x, geom.y]};
        else if (geom.paths) gjGeom = {type:'LineString', coordinates: geom.paths};
      }
      // Convert attributes, and keep the original attributes as properties.
      return {type:'Feature', geometry: gjGeom, properties: f.attributes || {}};
    });
    return {type:'FeatureCollection', features};
  }
  return data;
}

function findOwnerField(properties) {
  const keys = Object.keys(properties);
  const ownerCandidates = ['OWNER', 'OWNER_NAME','OWNERNAME','Owner','OWNERNM','OWNERNM1','CONAME','OWNNAME'];
  for (const c of ownerCandidates) {
    const match = keys.find(k => k.toUpperCase() === c.toUpperCase());
    if (match) return match;
  }
  // fallback to first property that looks like a name (contains 'owner' or 'coname')
  const fallback = keys.find(k => /owner|ownern|coname/i.test(k));
  return fallback || null;
}

// Main sequence: get Morningside neighborhood polygon, then query parcels in Fulton + DeKalb that intersect it,
// intersect those parcels with City zoning to check they are single-family, compute area, and filter by area threshold.
async function loadParcels() {
  document.getElementById('runBtn').disabled = true;
  resultsLayer.clearLayers();
  neighborhoodLayer.clearLayers();
  try {
    // 1) fetch neighborhood polygon for Morningside (NAME contains 'Morningside' OR 'Morningside-Lenox' or 'Morningside/Lenox')
    const nbParams = {
      where: "UPPER(NAME) LIKE '%MORNINGSIDE%' OR UPPER(NAME) LIKE '%MORNINGSIDE-LOWE%'",
      outFields: 'NAME,ACRES,OBJECTID,OLDNAME',
      f: 'json',
      returnGeometry: 'true'
    };
    const nbGeo = await arcgisQueryToGeoJSON(ATL_NEIGHBORHOODS_URL, nbParams);
    if (!nbGeo.features || nbGeo.features.length === 0) {
      alert('Could not find a neighborhood polygon named Morningside. The map will still attempt to query parcels by approximate bbox around typical Morningside coordinates.');
      // fallback: use a user-specified bbox near Morningside center
    } else {
      // use the first matching polygon
      const nbFeature = nbGeo.features[0];
      neighborhoodLayer.addData(nbFeature);
      map.fitBounds(L.geoJSON(nbFeature).getBounds(), {padding:[20,20]});
      var nbGeom = nbFeature.geometry;
    }

    // Convert neighborhood geometry to ArcGIS JSON polygon for spatial query; if not found use bounding box of map center
    let queryGeom = null;
    if (nbGeo.features && nbGeo.features.length>0) {
      queryGeom = nbGeo.features[0].geometry; // GeoJSON polygon (coordinates in lon/lat)
    } else {
      const b = map.getBounds();
      queryGeom = { type:'Polygon', coordinates: [[
        [b.getWest(), b.getSouth()],
        [b.getEast(), b.getSouth()],
        [b.getEast(), b.getNorth()],
        [b.getWest(), b.getNorth()],
        [b.getWest(), b.getSouth()]
      ]] };
    }

    // prepare geometry parameter for ArcGIS: extend to GeoJSON then encode as JSON and sr=4326
    const geometryParam = encodeURIComponent(JSON.stringify(queryGeom));

    // 2) Query Fulton Parcels (request geometry and attributes)
    // We'll ask for all fields (outFields=*) and request GeoJSON format if available.
    const fParams = {
      geometry: geometryParam,
      geometryType: 'esriGeometryPolygon',
      spatialRel: 'esriSpatialRelIntersects',
      inSR: 4326,
      outFields: '*',
      outSR: 4326,
      f: 'json',
      // Note: some services require 'where=1=1' parameter; include it.
      where: '1=1'
    };

    // Helper to query a parcel service and return GeoJSON
    async function queryParcelService(serviceUrl) {
      const qc = await arcgisQueryToGeoJSON(serviceUrl, fParams);
      return qc;
    }

    const [fultonGeo, dekalbGeo] = await Promise.all([
      queryParcelService(FULTON_PARCELS_URL),
      queryParcelService(DEKALB_PARCELS_URL)
    ]);

    // combine features
    const combined = {type:'FeatureCollection', features: []};
    if (fultonGeo && fultonGeo.features) combined.features.push(...fultonGeo.features);
    if (dekalbGeo && dekalbGeo.features) combined.features.push(...dekalbGeo.features);

    if (combined.features.length === 0) {
      alert('No parcels found in the neighborhood polygon. Possible reasons: service blocked, CORS, or polygon name mismatch.');
    }

    // 3) For each parcel, compute acreage (using turf). Then intersect/parity with zoning layer.
    const goodFeatures = [];
    // To reduce calls, fetch zoning polygons that intersect the neighborhood once
    const zoningParams = {
      geometry: geometryParam,
      geometryType: 'esriGeometryPolygon',
      spatialRel: 'esriSpatialRelIntersects',
      inSR: 4326,
      outFields: '*',
      outSR: 4326,
      f: 'json',
      where: '1=1'
    };
    const zoningGeo = await arcgisQueryToGeoJSON(ATL_ZONING_URL, zoningParams);
    // Convert zoning features to turf features for spatial tests
    const zoningTurf = (zoningGeo && zoningGeo.features) ? zoningGeo.features.map(f => f) : [];

    for (const feat of combined.features) {
      // Some ArcGIS responses include geometries in webMercator coords (x,y). Our simple converter may not always work.
      if (!feat.geometry) continue;
      // ensure GeoJSON polygon is in lon/lat coordinates; if coordinates look like [ [ [x,y],... ] ] and values are large, we assume they're already meters and skip (not ideal).
      // Use turf to compute area (in sq meters) then convert to sq ft.
      const area_m2 = Math.abs(turf.area(feat));
      const area_sqft = area_m2 * 10.76391041671;
      const acres = area_sqft / 43560.0;
      feat.properties._area_sqft = Math.round(area_sqft);
      feat.properties._area_acres = Number(acres.toFixed(4));

      // quick filter by area
      if (area_sqft < MIN_SQFT) continue;

      // find owner field dynamically
      const ownerField = (function(props){
        const keys = Object.keys(props);
        const ownerCandidates = ['OWNER','OWNER_NAME','OWNERNAME','Owner','OWNERNM','OWNER1','OWNNAME','CONAME'];
        for (const c of ownerCandidates) {
          const k = keys.find(k => k.toUpperCase() === c.toUpperCase());
          if (k) return k;
        }
        // fallback: find any field with 'owner' in name
        return keys.find(k => /owner/i.test(k)) || null;
      })(feat.properties);

      // parcel centroid for spatial query to zoning polygons
      const centroid = turf.centroid(feat);
      // find zoning polygon that contains centroid
      const matchedZone = zoningTurf.find(zf => turf.booleanPointInPolygon(centroid, zf));

      // Check zoning match
      let isSF = false;
      if (matchedZone) {
        if (isSingleFamilyZone(matchedZone.properties)) isSF = true;
      } else {
        // If no zoning polygon found (e.g., parcels outside city limits), we attempt to infer from parcel properties like LANDUSE/LANDUSE_DESC
        const p = feat.properties || {};
        const landuse = String(p.LANDUSE || p.LAND_USE || p.LANDUSE_DESC || '').toLowerCase();
        if (landuse.includes('single') || landuse.includes('res') || /^r/i.test(String(p.CLASS || p.PARCEL_CLASS || ''))) isSF = true;
      }
      if (!isSF) continue;

      // attach display fields
      const owner = ownerField ? (feat.properties[ownerField] || '') : '';
      const display = {
        owner: owner,
        apn: feat.properties.PARCELID || feat.properties.PIN || feat.properties.APN || feat.properties.ParcelID || feat.properties.Parcel || '',
        address: feat.properties.SITEADDR || feat.properties.SITUS || feat.properties.ADDRESS || feat.properties.SITE_ADDR || feat.properties.Address || '',
        acreage: feat.properties._area_acres,
        sqft: feat.properties._area_sqft,
        zone: matchedZone ? (matchedZone.properties.ZONECLASS || matchedZone.properties.ZoneClass || matchedZone.properties.ZONECLASSNAME || '') : ''
      };
      feat.properties._display = display;
      goodFeatures.push(feat);
    }

    // Add to map
    const gj = {type:'FeatureCollection', features: goodFeatures};
    resultsLayer.addData(gj);
    // bind popups
    resultsLayer.eachLayer(layer => {
      const p = layer.feature.properties._display || {};
      const html = `<div style="font-size:13px"><strong>${p.address || 'No address'}</strong><br/>
        Owner: ${p.owner || 'n/a'}<br/>
        APN: ${p.apn || 'n/a'}<br/>
        Zone: ${p.zone || 'n/a'}<br/>
        Area: ${p.acreage} ac (${p.sqft} sq ft)</div>`;
      layer.bindPopup(html);
    });

    if (goodFeatures.length===0) {
      alert('No parcels matched the filter (single-family zoning + ≥ 0.25 ac). Check README for notes about zoning codes and ownership availability.');
    } else {
      alert('Found ' + goodFeatures.length + ' parcels matching criteria. Use "Export GeoJSON" to download the result.');
      document.getElementById('exportBtn').disabled = false;
    }

    // store for export
    window._morningsideResult = gj;

  } catch (err) {
    console.error(err);
    alert('Error: ' + err.message);
  } finally {
    document.getElementById('runBtn').disabled = false;
  }
}

// Export the GeoJSON currently in memory
function download(filename, text) {
  const element = document.createElement('a');
  element.setAttribute('href', 'data:application/geo+json;charset=utf-8,' + encodeURIComponent(text));
  element.setAttribute('download', filename);
  element.style.display = 'none';
  document.body.appendChild(element);
  element.click();
  document.body.removeChild(element);
}

document.getElementById('runBtn').addEventListener('click', loadParcels);
document.getElementById('exportBtn').addEventListener('click', ()=>{
  if (!window._morningsideResult) return alert('No results to export. Click "Load parcels" first.');
  const geojson = JSON.stringify(window._morningsideResult);
  const fname = 'morningside_singlefamily_0.25ac_parcels.geojson';
  download(fname, geojson);
});

</script>
</body>
</html>
