
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Morningside Single-Family Parcels ≥ 0.25 ac (JSONP)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html,body,#map { height: 100%; margin:0; padding:0; }
    .controls { position: absolute; top:8px; right:8px; z-index:999; background:white; padding:8px; border-radius:6px; box-shadow:0 1px 4px rgba(0,0,0,0.3); font-family: Arial, sans-serif; }
    .btn { display:inline-block; padding:6px 8px; margin:4px 0; background:#1976d2; color:white; border-radius:4px; cursor:pointer; text-decoration:none; }
    .btn:disabled { background: #999; cursor: default; }
  </style>
</head>
<body>
<div id="map"></div>
<div class="controls">
  <div><strong>Morningside / Lenox Park — Single‑Family ≥ 0.25 ac</strong></div>
  <div style="margin-top:6px;">
    <button id="runBtn" class="btn">Load parcels</button>
    <button id="exportBtn" class="btn" disabled>Export GeoJSON</button>
  </div>
  <div style="margin-top:8px;font-size:12px;">
    Uses JSONP to bypass CORS; should work on GitHub Pages.
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
<script>
// --- ArcGIS REST endpoints ---
const ATL_NEIGHBORHOODS_URL = 'https://gis.atlantaga.gov/dpcd/rest/services/OpenDataService1/MapServer/3/query';
const ATL_ZONING_URL = 'https://gis.atlantaga.gov/dpcd/rest/services/OpenDataService1/MapServer/22/query';
const FULTON_PARCELS_URL = 'https://gismaps.fultoncountyga.gov/arcgispub2/rest/services/PropertyMapViewer/PropertyMapViewer/MapServer/0/query';
const DEKALB_PARCELS_URL = 'https://dcgis.dekalbcountyga.gov/hosted/rest/services/Parcels/MapServer/0/query';

// 0.25 acre in sq ft
const MIN_SQFT = 10890;

// Leaflet map
const map = L.map('map').setView([33.798, -84.358], 14);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom:19, attribution:'© OpenStreetMap contributors'}).addTo(map);

let resultsLayer = L.geoJSON(null, {style: ()=>({color:'#ff7800', weight:1.5, fill:false})}).addTo(map);
let neighborhoodLayer = L.geoJSON(null, {style: ()=>({color:'#1976d2', weight:2, fill:false})}).addTo(map);

// JSONP helper
function arcgisJSONP(url, params = {}){
  return new Promise((resolve, reject)=>{
    const cbName = 'jsonp_cb_' + Math.random().toString(36).slice(2);
    params.f = 'json';
    params.outSR = 4326;
    const qs = new URLSearchParams(params);
    qs.set('callback', cbName);
    const script = document.createElement('script');
    script.src = url + '?' + qs.toString();
    window[cbName] = (data)=>{
      delete window[cbName];
      document.body.removeChild(script);
      resolve(data);
    };
    script.onerror = ()=>{
      delete window[cbName];
      document.body.removeChild(script);
      reject(new Error('JSONP request failed'));
    };
    document.body.appendChild(script);
  });
}

// ArcGIS JSON -> GeoJSON (very simple for polygons)
function esriToGeoJSON(fc){
  if (!fc || !fc.features) return {type:'FeatureCollection', features:[]};
  const out = {type:'FeatureCollection', features:[]};
  for (const f of fc.features){
    let gjGeom = null;
    const g = f.geometry;
    if (g){
      if (g.rings) gjGeom = {type:'Polygon', coordinates: g.rings};
      else if (g.paths) gjGeom = {type:'LineString', coordinates: g.paths[0]};
      else if (g.x!=null && g.y!=null) gjGeom = {type:'Point', coordinates:[g.x, g.y]};
    }
    out.features.push({type:'Feature', geometry: gjGeom, properties: f.attributes || {}});
  }
  return out;
}

function isSingleFamilyZone(zoneProps){
  if (!zoneProps) return false;
  const z = String(zoneProps.ZONECLASS || zoneProps.ZoneClass || zoneProps.ZONE || '').toLowerCase();
  if (z.includes('single')) return true;
  if (/^r/.test(z)) return true; // R-1, R-2, etc.
  return false;
}

function ownerFieldName(props){
  const keys = Object.keys(props||{});
  const candidates = ['OWNER','OWNER_NAME','OWNERNAME','OWNERNM','CONAME','OWNNAME','OWNER1','OWNER_NM'];
  for (const c of candidates){
    const hit = keys.find(k => k.toUpperCase() === c);
    if (hit) return hit;
  }
  return keys.find(k => /owner/i.test(k)) || null;
}

async function loadParcels(){
  document.getElementById('runBtn').disabled = true;
  resultsLayer.clearLayers();
  neighborhoodLayer.clearLayers();
  try {
    // 1) Neighborhood polygon
    const nb = await arcgisJSONP(ATL_NEIGHBORHOODS_URL, {
      where: "UPPER(NAME) LIKE '%MORNINGSIDE%' OR UPPER(NAME) LIKE '%LENOX%'",
      outFields: 'NAME,OBJECTID',
      returnGeometry: true
    });
    const nbGJ = esriToGeoJSON(nb);
    if (!nbGJ.features.length) throw new Error('Neighborhood not found.');
    const nbFeat = nbGJ.features[0];
    neighborhoodLayer.addData(nbFeat);
    map.fitBounds(L.geoJSON(nbFeat).getBounds(), {padding:[20,20]});

    const geomParam = JSON.stringify(nb.features[0].geometry); // use ESRI geometry for spatialRel in parcel queries

    // 2) Query Fulton & DeKalb parcels that intersect the neighborhood
    const parcelParams = {
      geometry: geomParam,
      geometryType: 'esriGeometryPolygon',
      spatialRel: 'esriSpatialRelIntersects',
      outFields: '*',
      returnGeometry: true,
      inSR: 4326
    };

    const [fulton, dekalb] = await Promise.all([
      arcgisJSONP(FULTON_PARCELS_URL, parcelParams),
      arcgisJSONP(DEKALB_PARCELS_URL, parcelParams)
    ]);
    const parcels = esriToGeoJSON(fulton);
    parcels.features.push(...esriToGeoJSON(dekalb).features);

    // 3) Zoning polygons intersecting neighborhood (City of Atlanta)
    const zoning = esriToGeoJSON(await arcgisJSONP(ATL_ZONING_URL, {
      geometry: geomParam,
      geometryType: 'esriGeometryPolygon',
      spatialRel: 'esriSpatialRelIntersects',
      outFields: '*',
      returnGeometry: true,
      inSR: 4326
    }));

    // 4) Filter parcels by area and zoning
    const matched = [];
    for (const p of parcels.features){
      if (!p.geometry || p.geometry.type!=='Polygon') continue;
      const area_m2 = Math.abs(turf.area(p));
      const sqft = area_m2 * 10.76391041671;
      if (sqft < MIN_SQFT) continue;

      // zoning by centroid within neighborhood zoning polys
      const centroid = turf.centroid(p);
      const z = zoning.features.find(zf => turf.booleanPointInPolygon(centroid, zf));
      const isSF = z ? isSingleFamilyZone(z.properties) : false;
      if (!isSF) continue;

      // owner and identifiers
      const of = ownerFieldName(p.properties);
      const owner = of ? p.properties[of] : '';
      const apn = p.properties.PARCELID || p.properties.APN || p.properties.PIN || p.properties.ParcelID || '';
      const address = p.properties.SITEADDR || p.properties.SITUS || p.properties.ADDRESS || p.properties.SITE_ADDR || '';

      p.properties._display = {
        owner, apn, address,
        sqft: Math.round(sqft),
        acres: Math.round((sqft/43560)*10000)/10000,
        zone: z ? (z.properties.ZONECLASS || z.properties.ZONE || '') : 'n/a'
      };
      matched.push(p);
    }

    const fc = {type:'FeatureCollection', features: matched};
    resultsLayer.addData(fc);
    resultsLayer.eachLayer(layer => {
      const d = layer.feature.properties._display || {};
      layer.bindPopup(`<div style="font-size:13px"><strong>${d.address||'No address'}</strong><br>
      Owner: ${d.owner||'n/a'}<br>APN: ${d.apn||'n/a'}<br>Zone: ${d.zone||'n/a'}<br>
      Area: ${d.acres} ac (${d.sqft} sq ft)</div>`);
    });

    if (matched.length===0){
      alert('No parcels matched (check zoning codes / area threshold).');
    } else {
      alert('Found ' + matched.length + ' parcels.');
      document.getElementById('exportBtn').disabled = false;
    }
    window._result = fc;
  } catch (e){
    console.error(e);
    alert('Failed to fetch (JSONP): ' + e.message);
  } finally {
    document.getElementById('runBtn').disabled = false;
  }
}

function download(filename, text) {
  const a = document.createElement('a');
  a.href = 'data:application/geo+json;charset=utf-8,' + encodeURIComponent(text);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}

document.getElementById('runBtn').addEventListener('click', loadParcels);
document.getElementById('exportBtn').addEventListener('click', ()=>{
  if (!window._result) return alert('No results yet. Click "Load parcels" first.');
  download('morningside_singlefamily_0.25ac_parcels.geojson', JSON.stringify(window._result));
});
</script>
</body>
</html>
